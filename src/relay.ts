import { IncomingMessage, Server } from "node:http";
import {WebSocketServer, WebSocket, RawData} from "ws"
import {Duplex} from "node:stream";
import {config} from "./config";

export interface RelayWebSocket extends WebSocket {
	// A unique identifier generated by the server on connection, used for debugging.
	socketId: string
	// The relay identifier supplied by the connecting socket used for relaying messages between sockets with the same relay id.
	relayId: string
}

export class RelayServer {
	server: Server;
	#wss: WebSocketServer

	constructor(server: Server) {
		this.server = server;
		this.#wss = new WebSocketServer({ noServer: true });
		server.on("upgrade", this.handleServerUpgrade.bind(this));
		this.#wss.on("connection", this.handleConnection.bind(this));
	}

	async handleServerUpgrade(req: IncomingMessage, socket: Duplex, head: Buffer) {
		// todo: validate that the request is a given path?
		if (!config().allowedOrigins.includes("*")) {
			if (!req.headers.origin || !config().allowedOrigins.includes(req.headers.origin)) {
				// todo: send error response of some kind?
				console.debug("not allowed origin")
				socket.destroy();
				return;
			}
		}

		if (config().adminSecret) {
			const adminToken = req.headers["sec-websocket-protocol"];
			if (typeof adminToken !== "string" || adminToken !== config().adminSecret) {
				// todo: send error response of some kind?
				console.debug("incorrect token")
				socket.destroy();
				return;
			}
		}

		if (!req.url || !req.url.startsWith("/v1/")) {
			// todo: send error response of some kind?
			console.debug("incorrect url")
			socket.destroy()
			return;
		}

		const relayId = req.url.replace("/v1/", "")
		if (!relayId) {
			// todo: send error response of some kind?
			console.debug("relay identifier not supplied")
			socket.destroy()
			return;
		}
		const socketId = crypto.randomUUID()

		// @ts-ignore --- Using custom type which expands WebSocket type with metadata
		this.#wss.handleUpgrade(req, socket, head, async (socket: RelayWebSocket) => {
			socket.socketId = socketId;
			socket.relayId = relayId;

			console.debug(`socket '${socket.socketId}' connected to relay ${relayId}`)
			this.#wss.emit("connection", socket, req);
		})
	}

	handleConnection(ws: RelayWebSocket) {
		// todo: is this needed?
		ws.on("error", console.error);

		ws.on("close", () => {
			console.debug(`socket '${ws.socketId}' closed`)
		});

		ws.on("message", async (data, isBinary) => {
			// todo: validate to a set of expected messages?
			// todo: apply rate limiting/abuse protection for clients?

			console.debug(`socket '${ws.socketId}' sent message`, data)
			this.handleMessage(ws, data, isBinary)
		});
	}

	handleMessage(sourceSocket: RelayWebSocket, data: RawData, isBinary?: boolean) {
		// todo: this forEach might scale badly with lots of connected sockets?
		// If so, sockets could be stored in a {relayId: socket[]} map to avoid looping over all clients.
		this.#wss.clients.forEach((client) => {
			if (client !== sourceSocket && (client as RelayWebSocket).relayId === sourceSocket.relayId && client.readyState === WebSocket.OPEN) {
				client.send(data, {binary: isBinary})
			}
		})
	}

	listen(port: number) {
		this.server.listen(port);
	}
}
